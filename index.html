<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MingleChang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="MingleChang">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="MingleChang">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MingleChang">
  
    <link rel="alternate" href="/atom.xml" title="MingleChang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MingleChang</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-firewalld命令使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/08/firewalld命令使用/" class="article-date">
  <time datetime="2017-02-08T14:20:40.000Z" itemprop="datePublished">2017-02-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/08/firewalld命令使用/">firewalld命令使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#1、firewalld的基本使用<br>启动： systemctl start firewalld<br>查看状态： systemctl status firewalld<br>停止： systemctl disable firewalld<br>禁用： systemctl stop firewalld  </p>
<p>#2.配置firewalld-cmd</p>
<p>查看版本： firewall-cmd –version<br>查看帮助： firewall-cmd –help<br>显示状态： firewall-cmd –state<br>查看所有打开的端口： firewall-cmd –zone=public –list-ports<br>更新防火墙规则： firewall-cmd –reload<br>查看区域信息:  firewall-cmd –get-active-zones<br>查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0<br>拒绝所有包：firewall-cmd –panic-on<br>取消拒绝状态： firewall-cmd –panic-off<br>查看是否拒绝： firewall-cmd –query-panic  </p>
<p>#开启或者关闭一个端口<br>添加<br>firewall-cmd –zone=public –add-port=80/tcp –permanent    （–permanent永久生效，没有此参数重启后失效）<br>重新载入<br>firewall-cmd –reload<br>查看<br>firewall-cmd –zone= public –query-port=80/tcp<br>删除<br>firewall-cmd –zone= public –remove-port=80/tcp –permanent  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/08/firewalld命令使用/" data-id="ciyx1ta2s0000rqc1sztyx71s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/firewalld/">firewalld</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Socket套接字API" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/24/Socket套接字API/" class="article-date">
  <time datetime="2016-12-24T03:52:12.000Z" itemprop="datePublished">2016-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/24/Socket套接字API/">Socket套接字API</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>IPv4套接字地址结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;netinet/in.h&gt;</div><div class="line">/*</div><div class="line"> * Internet address (a structure for historical reasons)</div><div class="line"> */</div><div class="line">struct in_addr &#123;</div><div class="line">    in_addr_t s_addr;</div><div class="line">&#125;;</div><div class="line">/*</div><div class="line"> * Socket address, internet style.</div><div class="line"> */</div><div class="line">struct sockaddr_in &#123;</div><div class="line">    __uint8_t	sin_len;</div><div class="line">    sa_family_t	sin_family;</div><div class="line">    in_port_t	sin_port;</div><div class="line">    struct	in_addr sin_addr;</div><div class="line">    char		sin_zero[8];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>IPv6套接字地址结构</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include &lt;netinet6/in6.h&gt;</div><div class="line">/*</div><div class="line"> * IPv6 address</div><div class="line"> */</div><div class="line">struct in6_addr &#123;</div><div class="line">    union &#123;</div><div class="line">        __uint8_t   __u6_addr8[16];</div><div class="line">        __uint16_t  __u6_addr16[8];</div><div class="line">        __uint32_t  __u6_addr32[4];</div><div class="line">    &#125; __u6_addr;			/* 128-bit IP6 address */</div><div class="line">&#125;;</div><div class="line">struct sockaddr_in6 &#123;</div><div class="line">    __uint8_t	sin6_len;	/* length of this struct(sa_family_t) */</div><div class="line">    sa_family_t	sin6_family;	/* AF_INET6 (sa_family_t) */</div><div class="line">    in_port_t	sin6_port;	/* Transport layer port # (in_port_t) */</div><div class="line">    __uint32_t	sin6_flowinfo;	/* IP6 flow information */</div><div class="line">    struct in6_addr	sin6_addr;	/* IP6 address */</div><div class="line">    __uint32_t	sin6_scope_id;	/* scope zone index */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>通用套接字地址结构</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">/*</div><div class="line"> * [XSI] Structure used by kernel to store most addresses.</div><div class="line"> */</div><div class="line">struct sockaddr &#123;</div><div class="line">    __uint8_t	sa_len;		/* total length */</div><div class="line">    sa_family_t	sa_family;	/* [XSI] address family */</div><div class="line">    char		sa_data[14];	/* [XSI] addr value (actually larger) */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>字节排序函数</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/_endian.h&gt;</div><div class="line">返回：网络字节序的值</div><div class="line">#define htons(x)	__DARWIN_OSSwapInt16(x)</div><div class="line">#define htonl(x)	__DARWIN_OSSwapInt32(x)</div><div class="line">返回：主机字节序的值</div><div class="line">#define ntohs(x)	__DARWIN_OSSwapInt16(x)</div><div class="line">#define ntohl(x)	__DARWIN_OSSwapInt32(x)</div></pre></td></tr></table></figure>
<p><strong>字节操纵函数</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;strings.h&gt;</div><div class="line">void	 bzero(void *, size_t)</div><div class="line">void	 bcopy(const void *, void *, size_t)</div><div class="line">int	 bcmp(const void *, const void *, size_t)</div></pre></td></tr></table></figure>
<p>bzero把目标字节串中指定数目的字节置为0，我们经常使用该函数来把一个套接字地址结构初始化为0。<br>bcopy将指定数目的字节从源字节串复制到目标字节串。<br>bcmp比较两个任意的字节串，若相同则返回值为0，否则返回值为非0。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;string.h&gt;</div><div class="line">void	*memset(void *__b, int __c, size_t __len);</div><div class="line">void	*memcpy(void *__dst, const void *__src, size_t __n);</div><div class="line">int	 memcmp(const void *__s1, const void *__s2, size_t __n);</div></pre></td></tr></table></figure>
<p>memset把目标字节串指定数目的字节置为__c。<br>memcpy类似bcopy，不过两个指针参数的顺序是相反的，当源字节串与目标字节串重叠时，bcopy能够正确处理，但是memcpy的操作结果却不可知。<br>memcmp比较两个任意的字节串，若相同则返回0，否则返回一个非0，是大于0还是小于0则取决于第一个不等的字节。</p>
<p><strong>inet_aton、inet_addr和inet_ntoa函数</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line">int		 inet_aton(const char *strptr, struct in_addr *addrptr);</div><div class="line">in_addr_t	 inet_addr(const char *strptr);</div><div class="line">char		*inet_ntoa(struct in_addr inaddr);</div></pre></td></tr></table></figure>
<p>inet_aton将strptr所指C字符串转换成一个32位的网络字节序二进制值，并通过指针addrptr来存储，若成功则返回1，否这返回0。<br>inet_addr进行相同的转换，返回的值为32位的网络字节序二进制值，出错时返回INADDR_NONE常值。该函数存在一个问题：  255.255.255.255不能有该函数处理，因为它的二进制值用来指示该函数失败。<br>inet_ntoa函数将一个32位的网络二进制IPv4地址转换成相应的点分十进制数串。</p>
<p><strong>inet_pton和inet_ntop函数</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line">int		 inet_pton(int family, const char *strptr, void *addrptr);</div><div class="line">const char	*inet_ntop(int family, const void *addrptr, char *strptr, socklen_t len);</div></pre></td></tr></table></figure>
<p>inet_pton尝试转换由strptr指针所指的字符串，并通过addrptr指针存放二进制结果。若成功则返回值为1，若输入不是有效的表达格式则为0，若出错则为-1<br>inet_ntop是进行相反的转换，从数值格式（addrptr）转换到表达式（strptr）。len参数是目标存储单元的大小，以免该函数溢出其调用者的缓冲区。为有助于指定这个大小，在头文件中有如下定义：<br><code>#define INET_ADDRSTRLEN 16</code><br><code>#define    INET6_ADDRSTRLEN    46</code><br>如果len太小，不足以容纳表达格式结果（包括结尾的空字符），那么返回一个空指针，并置errno为ENOSPC。<br>inet_ntop函数的strptr参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小。调用成功时，这个指针就是该函数的返回值。</p>
<p><strong>socket函数</strong><br>为了执行网络I/O，一个进程必须做的第一件事就是调用socket函数，指定期望的通信协议类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int	socket(int family, int type, int protocol);</div></pre></td></tr></table></figure>
<p>family参数指名协议族，该参数也往往被称为协议域。  </p>
<table>
<thead>
<tr>
<th style="text-align:center">family</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">AF_INET</td>
<td style="text-align:center">IPv4协议</td>
</tr>
<tr>
<td style="text-align:center">AF_INET6</td>
<td style="text-align:center">IPv6协议</td>
</tr>
<tr>
<td style="text-align:center">AF_LOCAL</td>
<td style="text-align:center">Unix域协议</td>
</tr>
<tr>
<td style="text-align:center">AF_ROUTE</td>
<td style="text-align:center">路由套接字</td>
</tr>
<tr>
<td style="text-align:center">AF_KEY</td>
<td style="text-align:center">密钥套接字</td>
</tr>
</tbody>
</table>
<p>type参数指名套接字类型。</p>
<table>
<thead>
<tr>
<th style="text-align:center">type</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOCK_STREAM</td>
<td style="text-align:center">字节流套接字</td>
</tr>
<tr>
<td style="text-align:center">SOCK_DGRAM</td>
<td style="text-align:center">数据报套接字</td>
</tr>
<tr>
<td style="text-align:center">SOCK_SEQPACKET</td>
<td style="text-align:center">有序分组套接字</td>
</tr>
<tr>
<td style="text-align:center">SOCK_RAW</td>
<td style="text-align:center">原始套接字</td>
</tr>
</tbody>
</table>
<p>protocol参数应设为某个协议类型常值，或者设为0，以选择给定的family和type组合的系统默认值；</p>
<table>
<thead>
<tr>
<th style="text-align:center">protocol</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IPPROTO_TCP</td>
<td style="text-align:center">TCP传输协议</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_UDP</td>
<td style="text-align:center">UDP传输协议</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_SCTP</td>
<td style="text-align:center">SCTP传输协议</td>
</tr>
</tbody>
</table>
<p>并非所有套接字family与type组合都是有效的，下表给出了一些有效的组合和对应的真正协议。其中标为“是”的项也是有效的，但还没有找到便捷的缩略词。而空白项则是无效组合。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">AF_INET</th>
<th style="text-align:center">AF_INET6</th>
<th style="text-align:center">AF_LOCAL</th>
<th style="text-align:center">AF_ROUTE</th>
<th style="text-align:center">AF_KEY</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOCK_STREAM</td>
<td style="text-align:center">TCP/SCTP</td>
<td style="text-align:center">TCP/SCTP</td>
<td style="text-align:center">是</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">SOCK_DGRAM</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center">UDP</td>
<td style="text-align:center">是</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">SOCK_SEQPACKET</td>
<td style="text-align:center">SCTP</td>
<td style="text-align:center">SCTP</td>
<td style="text-align:center">是</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">SOCK_RAW</td>
<td style="text-align:center">IPv4</td>
<td style="text-align:center">IPv6</td>
<td style="text-align:center"></td>
<td style="text-align:center">是</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<p>socket函数在成功时返回一个小的非负整数值，它与文件描述符类似，我们把它称为套接字描述符(socket descrptor)，简称sockfd。为了得到这个套接字描述符，我们只是指定了协议族(IPv4、IPv6和Unix)和套接字类型(字节流、数据报或原始套接字)。我们并没有指定本地协议地址和远程协议地址。</p>
<p><strong>connect函数</strong><br>TCP客户端用connect函数来建立与TCP服务器的连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int	connect(int sockfd, const struct sockaddr *servaddr, socklen_t addrlen);</div></pre></td></tr></table></figure>
<p>sockfd是由socket函数返回的套接字描述符，第二个、第三个参数分别是一个指向套接字地址结构的指针和该结构的大小，套接字地址结构必须含有服务器的IP地址和端口号。</p>
<p><strong>bind函数</strong><br>bind函数把一个本地协议地址赋予一个套接字，对于网际网协议，协议地址是32位的IPv4地址或128位的IPv6地址与16位的TCP或UDP端口号的组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int	bind(int sockfd, const struct sockaddr *myaddr, socklen_t addrlen)</div></pre></td></tr></table></figure>
<p>第二个参数是一个指向特定协议的地址结构的指针，第三个参数是该地址结构的长度。对于TCP，调用bind函数可以指定一个端口号，或指定一个IP地址，也可以两者都指定，还可以都不指定。 </p>
<table>
<thead>
<tr>
<th style="text-align:center">IP地址</th>
<th style="text-align:center">断开</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">通配地址</td>
<td style="text-align:center">0</td>
<td style="text-align:left">内核选择IP地址和端口</td>
</tr>
<tr>
<td style="text-align:center">通配地址</td>
<td style="text-align:center">非0</td>
<td style="text-align:left">内核选择IP地址，进程指定端口</td>
</tr>
<tr>
<td style="text-align:center">本地IP地址</td>
<td style="text-align:center">0</td>
<td style="text-align:left">进程指定IP地址，内核选择端口</td>
</tr>
<tr>
<td style="text-align:center">本地IP地址</td>
<td style="text-align:center">非0</td>
<td style="text-align:left">进程指定IP地址和端口</td>
</tr>
</tbody>
</table>
<p><strong>listen函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int	listen(int sockfd, int backlog);//返回：若成功则为0，若出错则为-1</div></pre></td></tr></table></figure>
<p>listen函数仅由TCP服务器调用，他做两件事情：  </p>
<ol>
<li>当socket函数创建一个套接字时，它被假设为一个主动套接字，也就是说，它是一个将调用connect发起连接的客户套接字。listen函数把一个未连接的套接字转换成一个被动套接字，指示内核应接受指向该套接字的连接请求。调用listen导致套接字从CLOSED状态转喊到LISTEN状态。  </li>
<li>第二个参数规定了内核应该为相应套接字排队的最大连接个数。</li>
</ol>
<p>本函数通常应该在调用socket和bind这两个函数之后，并在调用accept函数之前调用。</p>
<p><strong>accept函数</strong><br>accept函数由TCP服务器调用，用于从已完成连接队列队头返回下一个已完成连接。如果已完成连接队列为空，那么进程被投入睡眠。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int	accept(int sockfd, struct sockaddr *cliaddr, socklen_t *addrlen);</div></pre></td></tr></table></figure>
<p>返回值：如果成功返回非负描述符，若出错则为-1<br>参数cliaddr和addrlen用来返回已连接的对端进程的协议地址。如果accept成功，那么其返回值是由内核自动生成的一个全新描述符，代表与所返回客户的TCP链接。</p>
<p><strong>fork和exec函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">pid_t	 fork(void);</div></pre></td></tr></table></figure>
<p>返回值：在子进程中为0，在父进程中为子进程ID，若出错则为-1<br>fork在子进程返回0而不是父进程的进程ID的原因在于：任何子进程只有一个父进程，而且子进程总是可以通过调用<code>getppid</code>取得父进程的进程ID。相反，父进程可以有许多子进程，而且无法获取各个子进程的进程ID。如果父进程想要跟踪所有子进程的进程ID，那么它必须记录每次调用fork的返回值。<br>父进程中调用fork之前打开的所有描述符在fork返回之后由子进程分享。<br>fork有两个典型用法：<br>1） 一个进程创建一个自身的副本，这样每个副本都可以在另一个副本执行其他任务的同时处理各自的某个操作。这是网络服务器的典型用法。<br>2) 一个进程想要执行另一个程序。既然创建新进程的唯一办法是调用fork，该进程于是首先调用fork创建一个自身的副本，然后其中一个副本（通常为子进程）调用<code>exec</code>把自身替换成新的程序。这是诸如shell之类程序的典型用法。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int	 execl(const char * __path, const char * __arg0, ...);</div><div class="line">int	 execv(const char * __path, char * const * __argv);</div><div class="line">int	 execle(const char * __path, const char * __arg0, ...);</div><div class="line"></div><div class="line">int	 execve(const char * __file, char * const * __argv, char * const * __envp);</div><div class="line">int	 execlp(const char * __file, const char * __arg0, ...);</div><div class="line">int	 execvp(const char * __file, char * const * __argv);</div></pre></td></tr></table></figure>
<p>返回值：若成功则不返回，若出错则为-1<br>这些函数只在出错时才返回到调用者。否则，控制将被传递给新程序的起始点，通常就是main函数。  </p>
<p><strong>close函数</strong>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int	 close(int sockfd);</div></pre></td></tr></table></figure>
<p>返回值：若成功则为0，若出错则为-1<br>close函数用来关闭套接字，并终止TCP连接。<br>close一个TCP套接字的默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。</p>
<p><strong>getsockname和getpeername函数</strong><br>这两个函数返回与某个套接字关联的本地协议地址(getsockname)，或者返回与某个套接字关联的外地协议地址(getpeername)。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int	getsockname(int sockfd, struct sockaddr * localaddr, socklen_t * addrlen);</div><div class="line">int	getpeername(int sockfd, struct sockaddr * localaddr, socklen_t * addrlen);</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/24/Socket套接字API/" data-id="ciyx1ta41000nrqc1n564io71" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Socket/">Socket</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS自动打包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/24/iOS自动打包/" class="article-date">
  <time datetime="2016-12-24T03:46:45.000Z" itemprop="datePublished">2016-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/24/iOS自动打包/">iOS自动打包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>做iOS开发这么久，一直给测试打包都是使用Xcode先进行Archive，然后再将对应的xcarchive文件Export为一个ipa文件。当然做了这么久感觉也没有什么不对的，但是前段时间我们老大希望能让我准备一个脚本，然后以后就让运维通过脚本打包，这样一想也的确省去不少麻烦，就算不让运维打包，我们自己用脚本也省去了不断点下一步的麻烦操作，于是我就开始通过谷歌和度娘查找相关资料，根据网上资料，网上流传的打包脚本无外两种：</p>
<p>第一种是先通过xcodebuild编译工程得到一个XXX.app文件，脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcodebuild -project XXXXXX.xcodeproj -scheme XXXXXX -configuration Release -sdk iphoneos build CODE_SIGN_IDENTITY=&quot;XXXXXX&quot; PROVISIONING_PROFILE=&quot;XXXXXXX&quot;</div><div class="line">xcodebuild -workspace XXXXXX.xcworkspace -scheme XXXXXX -configuration Release -sdk iphoneos build CODE_SIGN_IDENTITY=&quot;XXXXXX&quot; PROVISIONING_PROFILE=&quot;XXXXXXX&quot;</div></pre></td></tr></table></figure>
<p>这里有两句脚本，这里的两句是二选一的，如果你是需要打包的是一个普通的project就是用第一句，如果你需要打包的是一个workspace（当你使用了CocoaPods添加第三方库，你就需要使用第二句）就用第二句。<br>然后在使用xcrun将XXX.app文件转为XXX.ipa，脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcrun -sdk iphoneos -v PackageApplication ./Build/Products/Release-iphoneos/XXXXXX.app -o bin/XXXXXX.ipa</div></pre></td></tr></table></figure>
<p>这里CODE_SIGN_IDENTITY等号后面的就是对应的开发者证书，PROVISIONING_PROFILE等号后面对应的是PROVISIONING_PROFILE的uuid。<br>这种方式打包相当于先在Xcode进行build，然后将Products目录下的app文件直接拖入iTunes所得，但是我并不建议该种方法，因为这种方法并不完全同于我们以前的打包流程。</p>
<p>第二种就是先通过xcodebuild archive将项目工程打包为xcarchive文件，脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xcodebuild archive -project XXXX.xcodeproj -scheme XXXX -archivePath bin/XXXX.xcarchive</div><div class="line">xcodebuild archive -workspace XXXX.xcworkspace -scheme XXXX -archivePath bin/XXXX.xcarchive</div></pre></td></tr></table></figure>
<p>这里同样是两句选一句，分别针对project和workspace<br>然后使用xcodebuild -exportArchive将xcarchive文件export为对应该ipa文件，脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xcodebuild -exportArchive -archivePath bin/XXXX.xcarchive -exportPath bin/$XXXX -exportFormat IPA -exportProvisioningProfile &quot;[PROVISION_PROFILE]&quot;</div></pre></td></tr></table></figure>
<p>这里就是将的xcarchive通过使用PROVISION_PROFILE文件打包为ipa文件，这里[PROVISION_PROFILE]代表项目对应的PROVISION_PROFILE文件的文件名。<br>这种方式的打包是最接近于我之前手动打包的方式。</p>
<p>这里附上完整脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#!/bin/sh</div><div class="line"></div><div class="line">PROJECT_NAME=&quot;XXXXX&quot;</div><div class="line">WORKSPACE_NAME=&quot;XXXXX&quot;</div><div class="line">PROVISION_PROFILE=&quot;XXXXXX&quot;</div><div class="line"></div><div class="line">rm -rf bin</div><div class="line"></div><div class="line"># 如果是打包xcodeproj就使用这句</div><div class="line"># xcodebuild archive -project $&#123;PROJECT_NAME&#125;.xcodeproj -scheme $&#123;PROJECT_NAME&#125; -archivePath bin/$&#123;PROJECT_NAME&#125;.xcarchive</div><div class="line"></div><div class="line"># 如果是打包xcworkspace就使用这句</div><div class="line">xcodebuild archive -workspace $&#123;WORKSPACE_NAME&#125;.xcworkspace -scheme $&#123;WORKSPACE_NAME&#125; -archivePath bin/$&#123;WORKSPACE_NAME&#125;.xcarchive</div><div class="line"></div><div class="line">xcodebuild -exportArchive -archivePath bin/$&#123;WORKSPACE_NAME&#125;.xcarchive -exportPath bin/$&#123;WORKSPACE_NAME&#125; -exportFormat IPA -exportProvisioningProfile &quot;$&#123;PROVISION_PROFILE&#125;&quot;</div></pre></td></tr></table></figure>
<p>这里只需修改PROJECT_NAME，WORKSPACE_NAME和PROVISION_PROFILE即可。<br>脚本地址：<a href="https://github.com/MingleChang/ios_auto_build.git" target="_blank" rel="external">ios_auto_build</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/24/iOS自动打包/" data-id="ciyx1ta350003rqc1ay92t53f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/打包/">打包</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS10-Notification-Content-Extension" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/24/iOS10-Notification-Content-Extension/" class="article-date">
  <time datetime="2016-12-24T03:13:56.000Z" itemprop="datePublished">2016-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/24/iOS10-Notification-Content-Extension/">iOS10 Notification Content Extension</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>iOS10对推送通知的增加了两个扩展框架，之前介绍了Notification Service Extension，允许在收到推送之后，通知展示之前对推送信息进行二次处理；而另一个就是Notification Content Extension，允许开发者对推送信息自定义一个展示界面，在这个界面里你可以自定义任何视图，但是有一个限制，这个界面不能有用户交互，也就是这个界面用户不能点击它。但是对于整个通知我还是可以继续使用actions进行交互。<br>首先我们介绍下这个推送界面的组成，当我收到一条新的推送，我们下拉这条推送就会出现下面如图界面：<br><img src="https://github.com/MingleChang/img/raw/master/2016/12/24/1.jpg" alt=""></p>
<p>Header是属于系统默认的部分，所有推送都有这个Header且不可修改</p>
<p>Custom Content就是我们要介绍的Notification Content Extension的内容，在这里你可以自定义为任何样式。</p>
<p>Default Content系统默认的推送展示样式，不可修改，但可以选择不显示（这个我们后面会说到）。</p>
<p>Actions就是我们之前介绍UserNotification.Framework是介绍过的，这里用户可以进行一些操作并体现到Custom Content中。</p>
<p>现在我们来创建一个Notification Content Extension的Target，Xcode会自动创建如下图的几个文件：<br><img src="https://github.com/MingleChang/img/raw/master/2016/12/24/2.png" alt=""></p>
<p>NotificationViewController就是我们Custom Conten的代码部分，MainInterface.storyboard就是布局部分，Info.plist就是配置文件。</p>
<p>打开Info.plist文件，我们可以看到如下内容：<br><img src="https://github.com/MingleChang/img/raw/master/2016/12/24/3.jpeg" alt=""></p>
<p>这里的UNNotificationExtensionCategory就是响应这个Content Extension的通知的categoryId，那如果有多个categoryId都对应的是这个Content Extension怎么办呢？那么我们可以将UNNotificationExtensionCategory改为一个数组，数组中包含多个categoryId，如图：<br><img src="https://github.com/MingleChang/img/raw/master/2016/12/24/4.jpg" alt="">  </p>
<p>UNNotificationExtensionInitialContentSizeRatio这个是Content Extension初始化时候的高宽比。</p>
<p>除了这两个我之前说过Default Content可以选择是否显示，那么如果我们希望不显示Default Content，我们可以在NSExtensionAttributes增加UNNotificationExtensionDefaultContentHidden并设置为YES，如图：<br><img src="https://github.com/MingleChang/img/raw/master/2016/12/24/5.jpg" alt=""> </p>
<p>然后我们在MainInterface.storyboard中的ViewController中增加一些子视图：<br><img src="https://github.com/MingleChang/img/raw/master/2016/12/24/6.jpg" alt="">  </p>
<p>一个imageView和两个Label，并将其关联为NotificationViewController的属性：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (weak, nonatomic) IBOutlet UIImageView *imageView;</div><div class="line">@property (weak, nonatomic) IBOutlet UILabel *titleLabel;</div><div class="line">@property (weak, nonatomic) IBOutlet UILabel *contentLabel;</div></pre></td></tr></table></figure>
<p>现在我们开始处理NotificationViewController，NotificationViewController实际上就是一个继承于UIViewController的一个视图控制器，但是他实现了UNNotificationContentExtension协议。<br>UNNotificationContentExtension协议主要有两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)didReceiveNotification:(UNNotification *)notification;</div><div class="line">@optional</div><div class="line">- (void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption option))completion;</div></pre></td></tr></table></figure>
<p>第一个方法是当NotificationContentExtension收到指定categoryId的推送时，那么就将会响应这个方法，然后我们可以根据通知内容设置我们的界面。<br>第二个方法是一个可选方法，这个就是当用户进行Actions的操作是，NotificationContentExtension会响应的方法，我们可以根据对应的Action修改NotificationContentExtension界面或者进行网络请求等操作。<br>我先根据我们收到推送修改对应的Content Extension界面，那么我们在didReceiveNotification：中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)didReceiveNotification:(UNNotification *)notification &#123;</div><div class="line">    self.imageView.image=[UIImage imageNamed:@&quot;push_image&quot;];</div><div class="line">    self.titleLabel.text=notification.request.content.title;</div><div class="line">    self.contentLabel.text=notification.request.content.body;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么当我们收到推送之后，我们的Content Extension界面界面将会展示如下：<br><img src="https://github.com/MingleChang/img/raw/master/2016/12/24/7.jpg" alt="">  </p>
<p>之前在介绍Service Extension时，我们可以根据推送请求一些图片等并设置到attachments，那么当我们在Content Extension中收到一个包含attachments的推送时，我们要如何展示，这里我们将代码如下修改：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)didReceiveNotification:(UNNotification *)notification &#123;</div><div class="line">    if (notification.request.content.attachments.count==0) &#123;</div><div class="line">        self.imageView.image=[UIImage imageNamed:@&quot;push_image&quot;];</div><div class="line">    &#125;else&#123;</div><div class="line">        UNNotificationAttachment *lAttachment=notification.request.content.attachments.firstObject;</div><div class="line">        if (lAttachment) &#123;</div><div class="line">            if ([lAttachment.URL startAccessingSecurityScopedResource]) &#123;</div><div class="line">                self.imageView.image = [UIImage imageWithContentsOfFile:lAttachment.URL.path];</div><div class="line">                dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">                    [lAttachment.URL stopAccessingSecurityScopedResource];</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    self.titleLabel.text=notification.request.content.title;</div><div class="line">    self.contentLabel.text=notification.request.content.body;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里如果我们收到的推送包含attachments内容，那么我们就将图片赋值给imageView，但是attachment是由系统管理的，系统会把它们单独的管理，这意味着它们存储在我们sandbox之外。所以这里我们要使用attachment之前，我们需要告诉iOS系统，我们需要使用它，并且在使用完毕之后告诉系统我们使用完毕了。对应上述代码就是-startAccessingSecurityScopedResource和-stopAccessingSecurityScopedResource的操作。<br>这是如果我们收到一个带图片的推送，Content Extension展示如下：  </p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/24/8.jpg" alt="">   </p>
<p>这里的imageView展示的就是在Service Extension下载的图片。</p>
<p>然后我们来介绍UNNotificationContentExtension协议的第二个方法，- (void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption option))completion<br>该方法有两个参数，第一个response就是点击Actions传递过来的参数，我们可以根据response来判断是点击了哪个Actions，并对其做对应的处理，第二个completion是一个block，当我处理完response后需要回调的block，系统根据该block做后续处理，这个block有一个参数UNNotificationContentExtensionResponseOption，这个是UNNotificationContentExtensionResponseOption是一个枚举，定义如下：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSUInteger, UNNotificationContentExtensionResponseOption) &#123;</div><div class="line">    UNNotificationContentExtensionResponseOptionDoNotDismiss,</div><div class="line">    UNNotificationContentExtensionResponseOptionDismiss,</div><div class="line">    UNNotificationContentExtensionResponseOptionDismissAndForwardAction,</div><div class="line">&#125; __IOS_AVAILABLE(10_0) __TVOS_UNAVAILABLE __WATCHOS_UNAVAILABLE __OSX_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>UNNotificationContentExtensionResponseOptionDoNotDismiss代表不关闭Content Extension<br>UNNotificationContentExtensionResponseOptionDismiss代表关闭Content Extension，这里需要注意如果点击的action类型为UNNotificationActionOptionForeground，Content Extension仍然不会关闭<br>UNNotificationContentExtensionResponseOptionDismissAndForwardAction代表关闭Content Extension，且打开App。<br>这里我们修改代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)didReceiveNotificationResponse:(UNNotificationResponse *)response completionHandler:(void (^)(UNNotificationContentExtensionResponseOption option))completion&#123;</div><div class="line">    if ([response.actionIdentifier isEqualToString:kCategoryTestInputKey]) &#123;</div><div class="line">        UNTextInputNotificationResponse *inputResponse=(UNTextInputNotificationResponse *)response;</div><div class="line">        NSString *lString=inputResponse.userText;</div><div class="line">        self.contentLabel.text=lString;</div><div class="line">    &#125;else if ([response.actionIdentifier isEqualToString:kCategoryTestConfirmKey]) &#123;</div><div class="line">        self.contentLabel.text=@&quot;Confirm&quot;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        completion(UNNotificationContentExtensionResponseOptionDismiss);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们根据对应的Action修改contentLabel的显示，并在1.5s后关闭Content Extension，当然你也可以在这里进行一些网络请求后在执行block。<br>那么我们在收到推送点击了Confirm后，Content Extension将修改为如下：<br><img src="https://github.com/MingleChang/img/raw/master/2016/12/24/9.jpg" alt="">  </p>
<p>对于Content Extension的介绍就如下了。</p>
<p>代码下载：<a href="https://github.com/MingleChang/UserNotificationsTest.git" target="_blank" rel="external">UserNotificationsTest</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/24/iOS10-Notification-Content-Extension/" data-id="ciyx1ta2y0001rqc1vbam5hnz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notification/">Notification</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS10/">iOS10</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS10-Notification-Service-Extension" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/21/iOS10-Notification-Service-Extension/" class="article-date">
  <time datetime="2016-12-21T14:32:49.000Z" itemprop="datePublished">2016-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/21/iOS10-Notification-Service-Extension/">iOS10 Notification Service Extension</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在iOS10之前，iOS的推送逻辑是服务器想苹果的APNS服务器发送一条消息，然后由APNS服务器推送到手机，然后由操作系统处理后直接展示给用户，这个过程如下：</p>
<p>服务器 → APNS → 操作系统 → 用户</p>
<p>可以看出，这个过程跟我们的App没有任何关系（除了注册推送，获取Token），推送来的任何信息我们都无法对其展示做处理，iOS10苹果推出了Notification Service Extension，使得推送来的的信息可以通过Service Notification进行二次处理，那么现在我们推送发送到展示的过程就变成了：</p>
<p>服务器 → APNS → 操作系统 → Service Extension → 用户</p>
<p>通过Notification Service Extension，我们能在收到推送一条新的推送之后的30s（据说是30s，未测试）之内对推送信息进行二次处理，然后再展示，当然如果我们在规定时间之内未能成功进行二次处理，系统还是会按照当前的推送信息进行展示。</p>
<p>首先我对我们的项目创建一个Notification Service Extension，Notification Service Extension跟以前的Today Extension一样都属于一个应用扩展，那么就需要创建一个Target：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/9.jpg" alt=""></p>
<p>然后如图选择：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/10.jpg" alt=""></p>
<p>点击Next，输入名称，我们在项目中就多出一个新的target：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/11.jpg" alt=""></p>
<p>这里Bundle Identifier就是项目的bundle id加上.扩展名称，所以我这里的Bundle Identifier为mingle.chang.joke.NotificationService，这里我们就创建一个Notification Service Extension。</p>
<p>接下来我来看下Notification Service Extension中的处理逻辑，Notification Service Extension为我们创建三个文件：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/12.jpg" alt=""></p>
<p>Info.plist就是Notification Service Extension的配置文件，而NotificationService.h和NotificationService.m则是我们对通知进行二次处理的地方，打开NotificationService.m可以看到，已经系统已经默认帮我们写好了两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler &#123;</div><div class="line">    self.contentHandler = contentHandler;</div><div class="line">    self.bestAttemptContent = [request.content mutableCopy];</div><div class="line"></div><div class="line">    self.contentHandler(self.bestAttemptContent);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)serviceExtensionTimeWillExpire &#123;</div><div class="line">    // Called just before the extension will be terminated by the system.</div><div class="line">    // Use this as an opportunity to deliver your &quot;best attempt&quot; at modified content, otherwise the original push payload will be used.</div><div class="line">    self.contentHandler(self.bestAttemptContent);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而我们需要做的也就是在这两个方法中进行处理，第一个方法- (void)didReceiveNotificationRequest:(UNNotificationRequest <em>)request withContentHandler:(void (^)(UNNotificationContent </em> _Nonnull))contentHandler就是当Service Extension收到推送时首先执行的方法，第二个方法- (void)serviceExtensionTimeWillExpire就是如果我们对推送的二次处理超时或者处理出现异常情况将会默认执行这个方法，所以对于我们来说主要对第一个方法进行修改，在之前如果我们收到这样一条推送：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;aps&quot;: &#123;</div><div class="line">    &quot;alert&quot;: &#123;</div><div class="line">      &quot;title&quot;: &quot;这是一个标题&quot;,</div><div class="line">      &quot;subtitle&quot;: &quot;这是一个副标题&quot;,</div><div class="line">      &quot;body&quot;: &quot;你收到一个内容&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;badge&quot;: 1,</div><div class="line">    &quot;sound&quot;: &quot;default&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么我们收到的推送将会是如下：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/13.jpg" alt=""></p>
<p>我们说过Notification Service Extension可以对推送进行二次处理之后在进行展示，那么需要我们做哪些处理呢？<br>首先我们需要后台在推送的JSON中增加一个mutable-content字段，且该字段的值为1，那么我们服务器发出的推送就会是下面这个JSON：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;aps&quot;: &#123;</div><div class="line">    &quot;alert&quot;: &#123;</div><div class="line">      &quot;title&quot;: &quot;这是一个标题&quot;,</div><div class="line">      &quot;subtitle&quot;: &quot;这是一个副标题&quot;,</div><div class="line">      &quot;body&quot;: &quot;你收到一个内容&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;badge&quot;: 1,</div><div class="line">    &quot;sound&quot;: &quot;default&quot;,</div><div class="line">    &quot;mutable-content&quot;: 1</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有推送中包含该字段，系统才会将推送发送给Service Extension进行二次处理，然后我们修改- (void)didReceiveNotificationRequest:(UNNotificationRequest <em>)request withContentHandler:(void (^)(UNNotificationContent </em> _Nonnull))contentHandler中的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler &#123;</div><div class="line">    self.contentHandler = contentHandler;</div><div class="line">    self.bestAttemptContent = [request.content mutableCopy];</div><div class="line">    </div><div class="line">    // 根据收到的推送request修改推送显示的信息</div><div class="line">    self.bestAttemptContent.title = [NSString stringWithFormat:@&quot;%@ [NotificationService]&quot;, self.bestAttemptContent.title];</div><div class="line">    self.bestAttemptContent.subtitle = [NSString stringWithFormat:@&quot;%@ [NotificationService]&quot;, self.bestAttemptContent.subtitle];</div><div class="line">    self.bestAttemptContent.body = [NSString stringWithFormat:@&quot;%@ [NotificationService]&quot;, self.bestAttemptContent.body];</div><div class="line">    </div><div class="line">    self.contentHandler(self.bestAttemptContent);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先我们介绍这个方法中的两个参数：<br>request：就是我们收到的推送请求<br>contentHandler：是我们对推送进行二次处理完成后的推送信息回调给系统或者通知中心的block<br>接下介绍该方法中的代码：<br>首先我们通过：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">self.contentHandler = contentHandler;</div><div class="line">self.bestAttemptContent = [request.content mutableCopy];</div></pre></td></tr></table></figure>
<p>将contentHandler和request.content赋值给属性contentHandler和bestAttemptContent；<br>然后我们通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.bestAttemptContent.title = [NSString stringWithFormat:@&quot;%@ [NotificationService]&quot;, self.bestAttemptContent.title];</div><div class="line">self.bestAttemptContent.subtitle = [NSString stringWithFormat:@&quot;%@ [NotificationService]&quot;, self.bestAttemptContent.subtitle];</div><div class="line">self.bestAttemptContent.body = [NSString stringWithFormat:@&quot;%@ [NotificationService]&quot;, self.bestAttemptContent.body];</div></pre></td></tr></table></figure>
<p>修改bestAttemptContent的title，subtitle和body；<br>最后我们通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.contentHandler(self.bestAttemptContent);</div></pre></td></tr></table></figure>
<p>将修改后的bestAttemptContent回调给系统或者通知中心，这样当我们收到推送信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;aps&quot;: &#123;</div><div class="line">    &quot;alert&quot;: &#123;</div><div class="line">      &quot;title&quot;: &quot;这是一个标题&quot;,</div><div class="line">      &quot;subtitle&quot;: &quot;这是一个副标题&quot;,</div><div class="line">      &quot;body&quot;: &quot;你收到一个内容&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;badge&quot;: 1,</div><div class="line">    &quot;sound&quot;: &quot;default&quot;,</div><div class="line">    &quot;mutable-content&quot;: 1</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后，系统展示的就会是：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/14.jpg" alt=""></p>
<p>可以看到，这里我们将收到的推送的title，subtitle和body都增加了[NotificationService]进行展示。<br>之前说过系统留给我们处理推送的时间是30s，而我们上面的处理估计连1s都不到，那么我们在这30s还能干点其他什么吗？<br>当然，这里留给我们处理足够长，我们能够处理很多东西，比如可以让服务器推送一段加密的信息，我们将信息解密之后在进行展示；又比如可以让服务器推送一条信息的唯一标识，然后我们通过唯一标识向服务器获取需要展示的信息；我们也可以在收到推送后向服务器下载图片，视频，语音进行展示，当然这些文件也有一些要求规定，如图：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/15.png" alt=""></p>
<p>这里我们以下载图片为例：<br>首先我们修改推送JSON，在推送JSON增加一个自定义的字段image，这个字段就是对应的图片的地址，这里我们收到推送JSON则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;aps&quot;: &#123;</div><div class="line">    &quot;alert&quot;: &#123;</div><div class="line">      &quot;title&quot;: &quot;这是一个标题&quot;,</div><div class="line">      &quot;subtitle&quot;: &quot;这是一个副标题&quot;,</div><div class="line">      &quot;body&quot;: &quot;你收到一个内容&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;badge&quot;: 1,</div><div class="line">    &quot;sound&quot;: &quot;default&quot;,</div><div class="line">    &quot;mutable-content&quot;: 1,</div><div class="line">    &quot;image&quot;: &quot;xxxxx&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后修改- (void)didReceiveNotificationRequest:(UNNotificationRequest <em>)request withContentHandler:(void (^)(UNNotificationContent </em> _Nonnull))contentHandler中的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler &#123;</div><div class="line">    self.contentHandler = contentHandler;</div><div class="line">    self.bestAttemptContent = [request.content mutableCopy];</div><div class="line">    </div><div class="line">    self.bestAttemptContent.title = [NSString stringWithFormat:@&quot;%@ [NotificationService]&quot;, self.bestAttemptContent.title];</div><div class="line">    self.bestAttemptContent.subtitle = [NSString stringWithFormat:@&quot;%@ [NotificationService]&quot;, self.bestAttemptContent.subtitle];</div><div class="line">    self.bestAttemptContent.body = [NSString stringWithFormat:@&quot;%@ [NotificationService]&quot;, self.bestAttemptContent.body];</div><div class="line">    </div><div class="line">    NSDictionary *lApsDic = self.bestAttemptContent.userInfo[@&quot;aps&quot;];</div><div class="line">    NSString *lImageUrl=lApsDic[@&quot;image&quot;];</div><div class="line">    if (lImageUrl.length&gt;0) &#123;</div><div class="line">        [self loadAttachmentForUrlString:lImageUrl withType:@&quot;png&quot; completionHandle:^(UNNotificationAttachment *attach) &#123;</div><div class="line">            if (attach) &#123;</div><div class="line">                self.bestAttemptContent.attachments = [NSArray arrayWithObject:attach];</div><div class="line">            &#125;</div><div class="line">            self.contentHandler(self.bestAttemptContent);</div><div class="line">        &#125;];</div><div class="line">    &#125;else&#123;</div><div class="line">        self.contentHandler(self.bestAttemptContent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们在之前修改body的后增加了图片下载和加入通知信息的代码，首先我们从推送信息中获取image字段，得到图片的链接地址，然后使用loadAttachmentForUrlString:withType:completionHandle:下载我们的图片，该方法的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (void)loadAttachmentForUrlString:(NSString *)urlStr withType:(NSString *)type completionHandle:(void(^)(UNNotificationAttachment *attach))completionHandler&#123;</div><div class="line">    __block UNNotificationAttachment *attachment = nil;</div><div class="line">    NSURL *attachmentURL = [NSURL URLWithString:urlStr];</div><div class="line">    </div><div class="line">    NSURLSession *session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];</div><div class="line">    NSURLSessionDownloadTask *lTask=[session downloadTaskWithURL:attachmentURL completionHandler:^(NSURL *temporaryFileLocation, NSURLResponse *response, NSError *error) &#123;</div><div class="line">        if (error != nil) &#123;</div><div class="line">            NSLog(@&quot;Error:%@&quot;, error.localizedDescription);</div><div class="line">        &#125; else &#123;</div><div class="line">            NSFileManager *fileManager = [NSFileManager defaultManager];</div><div class="line">            NSURL *localURL = [NSURL fileURLWithPath:[temporaryFileLocation.path stringByAppendingPathExtension:type]];</div><div class="line">            [fileManager moveItemAtURL:temporaryFileLocation toURL:localURL error:&amp;error];</div><div class="line">            </div><div class="line">            NSError *attachmentError = nil;</div><div class="line">            attachment = [UNNotificationAttachment attachmentWithIdentifier:@&quot;&quot; URL:localURL options:nil error:&amp;attachmentError];</div><div class="line">            if (attachmentError) &#123;</div><div class="line">                NSLog(@&quot;Error:%@&quot;, attachmentError.localizedDescription);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completionHandler(attachment);</div><div class="line">    &#125;];</div><div class="line">    [lTask resume];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法就是用于图片下载，并将下载的图片生成一个UNNotificationAttachment对象，然后通过block回调给- (void)didReceiveNotificationRequest:(UNNotificationRequest <em>)request withContentHandler:(void (^)(UNNotificationContent </em> _Nonnull))contentHandler中，然后使用self.bestAttemptContent.attachments = [NSArray arrayWithObject:attach];对bestAttemptContent.attachments进行赋值，最后执行self.contentHandler(self.bestAttemptContent);通过这样，当我们收到上面的推送之后展示给用户的就会是如图所示：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/16.jpg" alt=""></p>
<p>下拉推送信息将会展示为：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/17.jpg" alt=""></p>
<p>这样我们就成功的推送了一条图片信息。</p>
<p>需要注意的地方：<br>一、是生成UNNotificationAttachment的时候，对应的图片文件名必须有正确的文件后缀名，否则在生成UNNotificationAttachment时将会抛出如下错误：<br>2016-10-30 23:08:17.135250 NotificationService[1581:190750] Error:Unrecognized attachment file type<br>二、如果我们需要对Notification Service Extension进行调试，需要选中Notification Service Extension的Target进行调试，如图：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/18.jpg" alt=""></p>
<p>三、如果在Notification Service Extension中的网络请求不是HTTPS，那么必须该Target的Info.plist中添加App Transport Security Settings说明。</p>
<p>代码下载：<a href="https://github.com/MingleChang/UserNotificationsTest.git" target="_blank" rel="external">UserNotificationsTest</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/21/iOS10-Notification-Service-Extension/" data-id="ciyx1ta360004rqc1yyobdr5q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notification/">Notification</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS10/">iOS10</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS10-UserNotification-Framework" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/12/21/iOS10-UserNotification-Framework/" class="article-date">
  <time datetime="2016-12-21T13:42:53.000Z" itemprop="datePublished">2016-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/12/21/iOS10-UserNotification-Framework/">iOS10 UserNotification.Framework</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作为一个App推送功能基本是每个App都会有的功能，尤其是国内应用，推送功能基本达到了滥用的地步，但是随着苹果公司对推送功能不断的加强，我们能通过推送实现更多的功能，尤其是这次iOS10的发布，增加了UserNotification.Framework，Notification Content和Notification Service Extension，推送功能变得更加强大。</p>
<p>这里主要是介绍UserNotification.Framework。</p>
<p>在iOS10之前我们注册通知的方式有两种，在iOS8之前我们使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[application registerForRemoteNotificationTypes:UIRemoteNotificationTypeAlert | UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound];</div></pre></td></tr></table></figure>
<p>在iOS8之后我们使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">UIUserNotificationSettings *settings = [UIUserNotificationSettings  settingsForTypes:UIUserNotificationTypeAlert | UIUserNotificationTypeBadge | UIUserNotificationTypeSound categories:nil];</div><div class="line">[application registerUserNotificationSettings:settings];</div><div class="line"></div><div class="line">- (void)application:(UIApplication *)application didRegisterUserNotificationSettings:(UIUserNotificationSettings *)settings</div><div class="line">&#123;</div><div class="line">    [application registerForRemoteNotifications];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后使用下面的方法获取token</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;Registration successful, bundle identifier: %@, device token: %@&quot;,[NSBundle.mainBundle bundleIdentifier], deviceToken);</div><div class="line">    NSString *pushToken = [[[[deviceToken description]</div><div class="line">                             stringByReplacingOccurrencesOfString:@&quot;&lt;&quot; withString:@&quot;&quot;] stringByReplacingOccurrencesOfString:@&quot;&gt;&quot; withString:@&quot;&quot;]</div><div class="line">                           stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];</div><div class="line">    NSLog(@&quot;device token: %@&quot;,pushToken);</div><div class="line">&#125;</div><div class="line">- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">NSLog(@&quot;Failed to register: %@&quot;, error);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后只需要后台通过APNS发送一条JSON：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;aps&quot;: &#123;</div><div class="line">    &quot;alert&quot;: &#123;</div><div class="line">      &quot;body&quot;: &quot;你收到一个内容&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;badge&quot;: 1,</div><div class="line">    &quot;sound&quot;: &quot;default&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在App端就能收到一条如下的推送：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/1.jpg" alt=""></p>
<p>以上就是在iOS10我们实现基本推送功能的方式，至于之前推送的一些其他功能可以自行百度或者谷歌。</p>
<p>在iOS10，苹果引入了一个新的Framework：UserNotification.Framework，将之前的RemoteNotification和LocalNotification的进行了统一处理，这里主要是对于RemoteNotification。</p>
<p>首先是注册通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[[UNUserNotificationCenter currentNotificationCenter] requestAuthorizationWithOptions:(UNAuthorizationOptionBadge | UNAuthorizationOptionSound | UNAuthorizationOptionAlert)</div><div class="line">completionHandler:^(BOOL granted, NSError * _Nullable error) &#123;</div><div class="line">    if (granted==YES) &#123;</div><div class="line">        NSLog(@&quot;request authorization succeeded!&quot;);</div><div class="line">        [application registerForRemoteNotifications];</div><div class="line">    &#125;else&#123;</div><div class="line">        NSLog(@&quot;request authorization failed!&quot;);</div><div class="line">        NSLog(@&quot;Error:%@&quot;,error);</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>UNUserNotificationCenter是用于专门管理推送通知的类，通过requestAuthorizationWithOptions向系统请求推送权限，请求完成后会有一个block的回调，如果granted为YES则代表获取权限成功，然后通过[application registerForRemoteNotifications]注册通知，获取token方式与之前，然后使用后台发起推送，就能收到跟之前一样的推送了。</p>
<p>在iOS10之前，一条推送上只能显示一句话，但是在iOS10之后如果我们推送下面这条JSON：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;aps&quot;: &#123;</div><div class="line">    &quot;alert&quot;: &#123;</div><div class="line">      &quot;title&quot;: &quot;这是一个标题&quot;,</div><div class="line">      &quot;subtitle&quot;: &quot;这是一个副标题&quot;,</div><div class="line">      &quot;body&quot;: &quot;你收到一个内容&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;badge&quot;: 1,</div><div class="line">    &quot;sound&quot;: &quot;default&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么你收到的推送将会是如下：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/2.jpg" alt=""></p>
<p>这里除了我们之前能看到的消息外，还额外增加了title（标题）和subtitle（副标题）的显示，当然如果还想有更复杂的推送显示，在iOS10中也可以通过Notification Service Extension实现，但不在这篇文章介绍。</p>
<p>有时我们需要在点击了推送进入app时根据推送内容进行对应的操作，在iOS10之前在UIApplicationDelegate提供了对应的处理方法，那么如果我们使用UserNotification.Framework又该如何实现这个功能，这里我们需要使用到UNUserNotificationCenterDelegate，UNUserNotificationCenterDelegate提供了两个代理方法，分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler</div><div class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler</div></pre></td></tr></table></figure>
<p>第一个代理方法是当应用处于前台时，收到推送时响应的代理方法，第二个代理方法是在点击了推送或者点击了推送的Action会响应的代理方法。</p>
<p>当然我们首先需要在注册推送的时候添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[UNUserNotificationCenter currentNotificationCenter]setDelegate:self];</div></pre></td></tr></table></figure>
<p>首先介绍第一个方法，当我们的程序正处于前台运行时候，这时候如果服务端向app发送了一个推送，那么我们的app将会响应到- (void)userNotificationCenter:(UNUserNotificationCenter <em>)center willPresentNotification:(UNNotification </em>)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler，这里我们可以看到该方法有三个参数：</p>
<p>第一个center就是我们注册推送使用的UNUserNotificationCenter。  </p>
<p>第二个参数notification就是我们收到的推送对象UNNotification，这里系统将推送信息整理成一个对象给我们处理，比以前直接传递一个Dictionary要有好很多，UNNotification中的个字段的含义就不一一说明了。</p>
<p>第三个参数completionHandler是一个block，在iOS10以前如果当系统App处于前台时收到推送，系统只会向App发出推送信息，但不会在界面上弹出推送提示语，但是现在我们可以使用completionHandler使我们处于前台时系统也会弹出推送提示信息，我们需要做的就是在这个代理方法中针对想要弹出提示框的推送执行如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert);</div></pre></td></tr></table></figure>
<p>那么当我们App处于前台时系统也会弹出提示信息，如图：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/3.jpg" alt=""></p>
<p>这样我们App处于前台时也能让系统弹出推送的提示信息。<br>UNNotificationPresentationOptionBadge，UNNotificationPresentationOptionSound，UNNotificationPresentationOptionAlert分别代表红点，声音和提示语，大家可以自行测试其功能。</p>
<p>第二个代理方法- (void)userNotificationCenter:(UNUserNotificationCenter <em>)center didReceiveNotificationResponse:(UNNotificationResponse </em>)response withCompletionHandler:(void(^)())completionHandler，当我们点击了推送的提示信息后，App将启动（如果App不处于前台）并执行该方法，这个代理方法也有三个参数：</p>
<p>第一个center就是我们注册推送使用的UNUserNotificationCenter。</p>
<p>第二个response我们点击推送后收到的UNNotificationResponse对象，UNNotificationResponse有两个变量，一个notification就是我们对应的UNNotification，另一个actionIdentifier是一个字符串，功能在后面说明。</p>
<p>第三个completionHandler是一个block，具体功能还在研究。<br>在该代理中我们添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler&#123;</div><div class="line">    NSString *lString=@&quot;点击了通知&quot;;</div><div class="line">    UIAlertController *lAlertController=[UIAlertController alertControllerWithTitle:lString message:nil preferredStyle:UIAlertControllerStyleAlert];</div><div class="line">    UIAlertAction *lOKAction=[UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    [lAlertController addAction:lOKAction];</div><div class="line">    [[UIApplication sharedApplication].keyWindow.rootViewController presentViewController:lAlertController animated:YES completion:nil];</div><div class="line">    completionHandler();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们点击了推送之后，App将启动，并弹出一个Alert，效果如下：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/4.jpg" alt=""></p>
<p>在iOS8的时候苹果提供了UIUserNotificationCategory，UIUserNotificationAction等相关类，可以在当程序在后台收到推送，对应的按钮或者输入文字后进入App进行不同的操作，效果如下：<br>当我们后台发送如下的推送信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;aps&quot;: &#123;</div><div class="line">    &quot;alert&quot;: &#123;</div><div class="line">      &quot;title&quot;: &quot;这是一个标题&quot;,</div><div class="line">      &quot;subtitle&quot;: &quot;这是一个副标题&quot;,</div><div class="line">      &quot;body&quot;: &quot;你收到一个内容&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;badge&quot;: 1,</div><div class="line">    &quot;sound&quot;: &quot;default&quot;,</div><div class="line">    &quot;category&quot;:&quot;category.test&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在收到推送后下拉这个推送：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/5.jpg" alt=""></p>
<p>点击confirm按钮：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/6.jpg" alt=""></p>
<p>如果点击text按钮：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/7.jpg" alt=""></p>
<p>点击send：</p>
<p><img src="https://github.com/MingleChang/img/raw/master/2016/12/21/8.jpg" alt=""></p>
<p>那么我们使用UserNotification.Framework，要如何实现该功能呢？<br>首先我们需要在注册通知的时候同时注册NotificationCategoriy:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self registerNotificationCategory];</div></pre></td></tr></table></figure>
<p>registerNotificationCategory方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static NSString *kCategoryTestKey=@&quot;category.test&quot;;</div><div class="line">static NSString *kCategoryTestInputKey=@&quot;category.test.input&quot;;</div><div class="line">static NSString *kCategoryTestConfirmKey=@&quot;category.test.confirm&quot;;</div><div class="line">-(void)registerNotificationCategory&#123;</div><div class="line">    UNTextInputNotificationAction *lTextAction=[UNTextInputNotificationAction actionWithIdentifier:kCategoryTestInputKey title:@&quot;text&quot; options:UNNotificationActionOptionForeground textInputButtonTitle:@&quot;send&quot; textInputPlaceholder:@&quot;please&quot;];</div><div class="line">    </div><div class="line">    UNNotificationAction *lConfirmAction=[UNNotificationAction actionWithIdentifier:kCategoryTestConfirmKey title:@&quot;Confirm&quot; options:UNNotificationActionOptionForeground];</div><div class="line">    </div><div class="line">    UNNotificationCategory *lCategory=[UNNotificationCategory categoryWithIdentifier:kCategoryTestKey actions:@[lTextAction,lConfirmAction] intentIdentifiers:@[] options:UNNotificationCategoryOptionNone];</div><div class="line">    [[UNUserNotificationCenter  currentNotificationCenter]setNotificationCategories:[NSSet setWithObjects:lCategory, nil]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们为UNUserNotificationCenter设置了一个identifier为category.test的category，这个category包含一个标题为text的文字输入的action（identifier为category.test.input），一个标题为confirm的按钮action（identifier为category.test.confirm）。</p>
<p>那么我们该如何处理各种action操作后需要执行的行为，这里我就要用到之前我们提到的UIApplicationDelegate中的第二个代理方法- (void)userNotificationCenter:(UNUserNotificationCenter <em>)center didReceiveNotificationResponse:(UNNotificationResponse </em>)response withCompletionHandler:(void(^)())completionHandler，之前我们提到第二个参数response还有一个actionIdentifier属性，这个属性就代表我们注册的category中各自action的identifier，那么我修改代理方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler&#123;</div><div class="line">    NSString *lString=@&quot;点击了通知&quot;;</div><div class="line">    if ([response.actionIdentifier isEqualToString:kCategoryTestInputKey]) &#123;</div><div class="line">        UNTextInputNotificationResponse *inputResponse=(UNTextInputNotificationResponse *)response;</div><div class="line">        lString=[NSString stringWithFormat:@&quot;点击了input,输入内容为:%@&quot;,inputResponse.userText];</div><div class="line">    &#125;else if([response.actionIdentifier isEqualToString:kCategoryTestConfirmKey])&#123;</div><div class="line">        lString=@&quot;点击了confirm&quot;;</div><div class="line">    &#125;</div><div class="line">    UIAlertController *lAlertController=[UIAlertController alertControllerWithTitle:lString message:nil preferredStyle:UIAlertControllerStyleAlert];</div><div class="line">    UIAlertAction *lOKAction=[UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    [lAlertController addAction:lOKAction];</div><div class="line">    [[UIApplication sharedApplication].keyWindow.rootViewController presentViewController:lAlertController animated:YES completion:nil];</div><div class="line">    completionHandler();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就可以实现前面同样的功能。</p>
<p>代码下载：<a href="https://github.com/MingleChang/UserNotificationsTest.git" target="_blank" rel="external">UserNotificationsTest</a> </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/12/21/iOS10-UserNotification-Framework/" data-id="ciyx1ta3d0005rqc1kalkdqk3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UserNotification/">UserNotification</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Notification/">Notification</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Socket/">Socket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UserNotification/">UserNotification</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/firewalld/">firewalld</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS10/">iOS10</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打包/">打包</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Notification/" style="font-size: 20px;">Notification</a> <a href="/tags/Socket/" style="font-size: 10px;">Socket</a> <a href="/tags/UserNotification/" style="font-size: 10px;">UserNotification</a> <a href="/tags/firewalld/" style="font-size: 10px;">firewalld</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/iOS10/" style="font-size: 20px;">iOS10</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a> <a href="/tags/打包/" style="font-size: 10px;">打包</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/08/firewalld命令使用/">firewalld命令使用</a>
          </li>
        
          <li>
            <a href="/2016/12/24/Socket套接字API/">Socket套接字API</a>
          </li>
        
          <li>
            <a href="/2016/12/24/iOS自动打包/">iOS自动打包</a>
          </li>
        
          <li>
            <a href="/2016/12/24/iOS10-Notification-Content-Extension/">iOS10 Notification Content Extension</a>
          </li>
        
          <li>
            <a href="/2016/12/21/iOS10-Notification-Service-Extension/">iOS10 Notification Service Extension</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 MingleChang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>